<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KMS Dev log</title>
    <link>https://thouy.github.io/</link>
    <description>Recent content on KMS Dev log</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Jan 2023 17:00:16 +0900</lastBuildDate><atom:link href="https://thouy.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Golang] Goroutine VS Thread</title>
      <link>https://thouy.github.io/posts/golang/goroutine_versus_thread/</link>
      <pubDate>Wed, 18 Jan 2023 17:00:16 +0900</pubDate>
      
      <guid>https://thouy.github.io/posts/golang/goroutine_versus_thread/</guid>
      <description>
        
          
            고루틴(Goroutine)은 Go 런타임이 관리하는 경량쓰레드입니다. 이번 포스팅에서는 OS 레벨의 쓰레드와 고루틴이 어떠한 차이가 있는지 살펴보고자 합니다.
[OS] 스레드(Thread)
메모리 점유 측면 고루틴은 생성 시 약 2KB의 스택 메모리 공간을 소모합니다. 필요에 따라 힙 메모리를 사용하기도 합니다. 쓰레드는 쓰레드가 사용할 메모리 공간과 더불어 Guard Page로 불리는 쓰레드와 쓰레드 사이의 메모리 공간까지 포함하기 때문에 약 1MB의 메모리 공간을 소모합니다. 때문에 쓰레드를 생성하면 할수록 가용 힙 메모리 공간이 계속 줄어드는 문제점이 있습니다. 생성 및 소거 비용 측면 고루틴은 Go 런타임이 논리적으로 생성하고 소거되므로 생성/소거에 드는 비용이 저렴합니다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>[Golang] Goroutine &amp; Channel</title>
      <link>https://thouy.github.io/posts/golang/goroutine_and_channel/</link>
      <pubDate>Wed, 18 Jan 2023 16:58:59 +0900</pubDate>
      
      <guid>https://thouy.github.io/posts/golang/goroutine_and_channel/</guid>
      <description>
        
          
            Goroutine(고루틴) 고루틴은 Go 런타임이 관리하는 가상쓰레드 입니다. Go에서 go 키워드를 사용하여 함수를 호출하면, Go는 런타임시에 새로운 고루틴을 생성합니다. 고루틴은 비동기적으로 함수를 실행하므로, 여러 함수를 동시에 실행하고자 할 때 사용됩니다. 고루틴은 OS의 쓰레드보다 더 가볍게 비동기 동시처리를 구현하기 위해 만들어 졌습니다. 때문에 고루틴은 OS의 쓰레드와 1:1로 대응되지 않고 훨씬 적은 OS의 쓰레드를 사용합니다. Go 런타임이 실행하는 모든 프로그램은 고루틴을 기반으로 동작합니다. main 함수도 고루틴으로 실행됩니다. 때문에 모든 Go 프로그램은 적어도 하나의 (메인)고루틴을 포함합니다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>[Javascript] Hoisting (호이스팅)</title>
      <link>https://thouy.github.io/posts/javascript/hoisting/</link>
      <pubDate>Wed, 18 Jan 2023 15:48:59 +0900</pubDate>
      
      <guid>https://thouy.github.io/posts/javascript/hoisting/</guid>
      <description>
        
          
            호이스팅이란 Hoist는 사전적으로 무거운 물건 및 무언가를 기계 등을 이용하여 위로 끌어 올리는 것(lift)을 의미합니다. 자바스크립트에서 호이스팅은 자바스크립트 Parser가 변수나 함수를 끌어 올려 최상단에 배치하는 것을 말합니다.
실제로 코드가 상단으로 올라가는 것은 아닙니다. 자바스크립트 Parser가 내부적으로 최상단에 끌어 올려서 처리하게 되며, 이 때 메모리 상의 변화는 없습니다.
호이스팅 대상 자바스크립트는 선언 구문만 호이스팅 합니다. 때문에 변수 선언 없이 먼저 변수를 사용하게 되더라도 예외가 발생하지 않습니다. 다만 그 변수는 사용되는 시점에 자동으로 기본 초기화 상태 (var 선언의 경우 undefined)가 됩니다.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Test1</title>
      <link>https://thouy.github.io/posts/test1/</link>
      <pubDate>Wed, 18 Jan 2023 15:34:49 +0900</pubDate>
      
      <guid>https://thouy.github.io/posts/test1/</guid>
      <description>
        
          
            Hello world 
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
