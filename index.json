[{"body":"개요 Fluentd 경량화 버전인 Fluentd Bit을 설치하는 과정을 정리한 글입니다.\nRequirements Cmake Flex YAML headers OpenSSL headers 1$ sudo apt-get install cmake, flex Install 1. Fluent Bit 소스코드 다운로드 1$ wget https://github.com/fluent/fluent-bit/archive/refs/tags/v2.0.8.tar.gz 2. build 디렉토리로 이동하여 Cmake 커멘드 실행 1$ cd fluent-bit-v2.0.8/build 2$ cmake ../ 3. make 커멘드 실행 1$ make 4. Fluent Bit 설치 1$ sudo make install 설치가 완료되면 /usr/local/bin 아래에 설치됩니다. 설정파일은 /usr/local/etc/fluent-bit/fluent-bit.conf에 있습니다. Configuration CPU, Disk, Memory, Network IO, Syslog를 tailing 하는 설정을 추가하려고 합니다. 출력은 표준입출력으로 설정했습니다. 1[INPUT] 2 name cpu 3 tag cpu.local 4 5 # Read interval (sec) Default: 1 6 interval_sec 1 7 8[INPUT] 9 name disk 10 tag disk.local 11 interval_sec 1 12 13[INPUT] 14 name mem 15 tag memory.local 16 interval_sec 1 17 18[INPUT] 19 name disk 20 tag disk.local 21 interval_sec 1 22 23[INPUT] 24 name netif 25 tag netif.local 26 interval_sec 1 27 interface eth0 28 29[OUTPUT] 30 name stdout 31 match * Run 아래의 명령으로 Fluent Bit을 실행합니다.\n1/usr/local/bin/fluent-bit -c /usr/local/etc/fluent-bit/fluent-bit.conf ","link":"https://thouy.github.io/posts/logging/fluent_bit_install/","section":"posts","tags":null,"title":"Fluent Bit Install"},{"body":"","link":"https://thouy.github.io/","section":"","tags":null,"title":"KMS Dev log"},{"body":"","link":"https://thouy.github.io/posts/logging/","section":"posts","tags":["logging"],"title":"Logging"},{"body":"","link":"https://thouy.github.io/posts/","section":"posts","tags":null,"title":"Posts"},{"body":"개요 오픈소스 기반 대표적인 Metrics collector인 Telegraf, Fluentd, Fluent Bit을 비교하고자 합니다.\nTelegraf vs Fluentd vs Fluent Bit Category Telegraf Fluentd Fluent Bit Scope Containers / Servers Embedded Linux / Containers / Servers Language Go Ruby \u0026amp; C C Memory About 35MB About 30MB About 650KB Dependencies Zero dependencies RubyGem Zero dependencies Binary size About 152M About 5.1M About 31M Support CPU metrics plugin Oinputs.cpu X OCPU plugin Support Disk metrics plugin Oinputs.disk X ODisk I/O plugin Support Memory metrics plugin Oinputs.mem X OMemory plugin Support NetworkIO metrics plugin Oinputs.net X ONetwork I/O plugin Support GPU metrics plugin O- NVIDIA : inputs.nvidia_smi- AMI : inputs.amd_rocm_smi X X Support Tailing plugin Oinputs.tail OTail plugin OTail plugin 출처는 각 오픈소스의 Official site 입니다. Metrics/Log collector를 선택하실 때 참고가 되셨으면 합니다.\n","link":"https://thouy.github.io/posts/logging/telegraf_versus_fluentd_versus_fluent_bit/","section":"posts","tags":null,"title":"Telegraf vs Fluentd vs Fluent Bit"},{"body":"개요 Fluentd + OpenSearch를 결합하여 syslog를 수집하는 시스템을 구축하는 내용에 대한 기록입니다.\n준비물 Ubuntu 20.04.5 LTS Fluentd가 설치된 환경 (버전 : v1.15.3) OpenSearch가 설치된 환경 (버전 : v2.4.1) 시스템 관련 디렉토리 정보 타켓 로그파일 : /var/log/syslog (rsyslog 데몬의 설정을 참고합니다. /etc/rsyslog.d/50-default.conf) Fluentd 설정파일 : /etc/fluentd/fluent.conf Fluentd 로그 관리용 디렉토리 : /var/log/fluentd 로그 파싱 전략 (syslog 한정) 로그 파싱은 Grok pattern을 활용합니다. syslog 구조 파악 시간, 호스트명, 프로세스명, 프로세스 아이디, 로그 본문으로 구분할 수 있습니다. 특수문자는 별도로 escape 처리가 필요할 수 있습니다. Grok Pattern 기본 문법은 아래와 같은 형태입니다.\n1${PATTERN_NAME:FIELD_NAME[:DATA_TYPE]} PATTERN_NAME에는 정의되어 있는 Grok 패턴명을 지정합니다. FIELD_NAME에는 패턴에 매치하는 값이 어떤 항목에 저장할지 지정합니다. DATA_TYPE에는 매치된 값의 데이터 유형을 지정합니다. 생략 가능하며, 생략할 경우 기본 string으로 지정됩니다. Logstash에서는 DATA_TYPE을 지정할 수 있는 항목이 없습니다.\n환경 설정 1. Fluentd 파트 Fluentd 플러그인 설치 필요한 Fluentd 플러그인을 추가로 설치해야 합니다. Grok 패턴을 이용하기 위한 Grok parser 플러그인과 OpenSearch 플러그인을 추가로 설치합니다.\n1$ sudo gem install fluent-plugin-grok-parser 2$ sudo gem install fluent-plugin-opensearch Fluentd 설정 - input 1\u0026lt;source\u0026gt; 2 @type tail 3 path /var/log/syslog 4 pos_file /var/log/fluentd/syslog-access.log.pos 5 tag syslog 6 refresh_interval 3 7 read_from_head false 8 \u0026lt;parse\u0026gt; 9 @type grok 10 \u0026lt;grok\u0026gt; 11 pattern %{SYSLOGTIMESTAMP:time:string}\\s+%{SYSLOGHOST:hostname:string}\\s+%{PROG:process:string}\\[%{POSINT:pid:integer}\\]:\\s+%{GREEDYDATA:message:string} 12 \u0026lt;/grok\u0026gt; 13 \u0026lt;/parse\u0026gt; 14\u0026lt;/source\u0026gt; 로그를 읽어오기 위해 tail 플러그인을 사용합니다. (https://docs.fluentd.org/input/tail) path에는 읽어올 로그파일 경로를 지정합니다. 와일드카드를 이용하여 다수의 로그파일 지정도 가능합니다. pos_file에는 현재까지 읽은 로그의 위치정보를 저장할 파일 경로를 지정합니다. 추가로 Grok 패턴을 적용하기 위해 Grok parser를 설정합니다. (https://github.com/fluent/fluent-plugin-grok-parser) pattern 값은 syslog 분석을 토대로 Grok 패턴식을 작성합니다. 특수문자는 escape 해야하며, 공백을 인식할 수 있도록 white space 정규식도 넣어줍니다. Fluentd 설정 - output 1\u0026lt;match syslog.**\u0026gt; 2 @type opensearch 3 host localhost 4 port 9200 5 user admin 6 password admin 7 scheme https 8 ssl_verify false 9 logstash_format true 10 logstash_prefix log 11 logstash_prefix_separator - 12\u0026lt;/match\u0026gt; OpenSearch를 사용하기 위해 OpenSearch 플러그인을 설정합니다. (https://github.com/fluent/fluent-plugin-opensearch) OpenSearch 접속 정보를 지정합니다. logstash_format을 활성화 하고 로그 데이터를 저장할 인덱스 이름의 prefix와 구분자를 지정합니다. 2. OpenSearch 파트 Index Template 정의하기 OpenSearch에 데이터를 저장하기 위해서는 먼저 인덱스와 mapping을 정의하는 과정이 필요합니다. mapping에는 Dynamic mapping과 Explicit mapping이 있으며 이 글에서는 Explicit mapping 방식으로 인덱스 템플릿을 정의하는 방법을 다룹니다.\n참고로 Elasticsearch도 동일합니다.\n생성할 인덱스 템플릿을 json으로 작성합니다. 1{ 2 \u0026#34;index_patterns\u0026#34;: [\u0026#34;logs-*\u0026#34;], 3 \u0026#34;template\u0026#34;: { 4 \u0026#34;aliases\u0026#34;: { 5 \u0026#34;logs\u0026#34;: {} 6 }, 7 \u0026#34;settings\u0026#34;: { 8 \u0026#34;number_of_shards\u0026#34;: 2, 9 \u0026#34;number_of_replicas\u0026#34;: 1 10 }, 11 \u0026#34;mappings\u0026#34;: { 12 \u0026#34;properties\u0026#34;: { 13 \u0026#34;hostname\u0026#34;: { 14 \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; 15 }, 16 \u0026#34;process\u0026#34;: { 17 \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; 18 }, 19 \u0026#34;pid\u0026#34;: { 20 \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; 21 }, 22 \u0026#34;time\u0026#34;: { 23 \u0026#34;type\u0026#34;: \u0026#34;date\u0026#34; 24 }, 25 \u0026#34;@timestamp\u0026#34;: { 26 \u0026#34;type\u0026#34;: \u0026#34;date\u0026#34; 27 }, 28 \u0026#34;message\u0026#34;: { 29 \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34; 30 } 31 } 32 } 33 } 34} OpenSearch REST API를 이용해서 작성한 json을 템플릿으로 등록합니다. 저는 크롬 확장 프로그램인 Talend API Tester를 활용했습니다. 1PUT https://localhost:9200/_index_template/log_template 3. rsyslog 파트 syslog파일은 640 권한으로 설정되어 있어서 root나 syslog 유저 외에는 파일을 읽을 수가 없습니다. 때문에 Fluentd가 syslog파일을 읽을 수 있도록 읽기 권한을 추가하는 과정이 필요합니다.\n1$ sudo chmod +r /var/log/syslog 추가로 rsyslog 설정에서 syslog 파일의 권한을 설정할 수 있습니다. /etc/rsyslog.conf 파일을 열어 FileCreateMode를 640에서 644로 수정합니다.\n1# 2# Set the default permissions for all log files. 3# 4$FileOwner syslog 5$FileGroup adm 6$FileCreateMode 0644 7$DirCreateMode 0755 8$Umask 0022 9$PrivDropToUser syslog 10$PrivDropToGroup syslog Run 설정이 다 마무리 되었으니 이제 Fluentd를 구동시킵니다. 각자 Fluentd를 설치한 방식에 맞는 실행 방법으로 Fluentd를 구동합니다. 저 같은 경우는 Fluentd를 소스코드로 빌드하여 설치하고 systemd 서비스로 별도로 등록했기 때문에 아래와 같이 실행시켰습니다.\n1$ sudo systemctl start fluentd 로그 데이터 확인 OpenSearch에 로그가 잘 적재되었는지 확인합니다. OpenSearch 대시보드를 돌리고 있다면 http://localhost:5601/ 에서 데이터를 확인해볼 수 있습니다.\n참고로 OpenSearch의 초기 관리자 계정은 admin/admin 입니다.\n","link":"https://thouy.github.io/posts/logging/fluentd_opensearch_log_monitoring/","section":"posts","tags":null,"title":"Fluentd + OpenSearch 로그 모니터링 시스템 구축기"},{"body":"개요 Fluentd는 오픈소스 기반의 Data collector이자 aggregator 입니다. Fluentd를 설치하는 방법은 td-agent 패키지를 이용해서 설치하는 방법과 소스를 직접 빌드하여 설치하는 방법이 있습니다. 본 글에서는 소스를 직접 빌드하여 Fluentd를 설치했던 과정을 다룹니다. 직접 설치했던 경험을 기반으로 작성되었습니다. 이 글이 Fluentd를 standalone으로 설치하시려는 분들에게 도움이 되셨으면 합니다. 설치 환경은 Ubuntu 20.04.5 LTS 입니다.\n준비물 Ruby source code archieve (v3.2.0) Fluentd source code archieve (v1.15.3) 설치 1. Ruby 설치 루비는 Fluentd 소스를 빌드하기 위해 필요하기 때문에 먼저 루비를 장비에 설치해야 합니다. 루비 설치 전 패키지 최신 목록을 업데이트한 후 다음의 패키지들이 설치되었는지 확인합니다.\n1$ sudo apt-get update 2$ sudo apt-get upgrade 3$ sudo apt-get install gcc, make, autoconf, bison, gperf, build-essential, libssl-dev, libreadline-dev, libffi-dev, zlib1g, zlib1g-dev 아래 명령으로 루비 소스코드 아카이브를 내려받은 후에 압축을 해제합니다.\n1$ wget https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.0.tar.gz 2$ tar xvzf ruby-3.2.0.tar.gz 압축이 해제된 루비 디렉토리로 이동하여 configure 스크립트를 실행합니다.\nprefix 옵션을 추가하면 루비가 설치될 경로를 지정할 수 있으며 지정하지 않으면 기본으로 /usr/local이 설정됩니다. disable-install-doc 옵션을 추가하면 루비 document 빌드 과정이 생략되기 때문에 좀 더 신속하게 루비를 설치할 수 있습니다. 1$ ./configure --prefix=/usr/local --disable-install-doc configure 스크립트 실행이 끝나면 make 명령으로 루비 소스를 빌드합니다.\n1$ make 빌드 과정에서 오류가 발생하면 ruby 디렉토리를 삭제한 후 다시 세팅해서 configure 절차부터 재시도 하는 것을 권장합니다.\nmake 빌드가 오류없이 완료되면 아래 명령으로 빌드한 루비를 설치합니다.\n1$ sudo make install 설치가 오류없이 완료되면 최종적으로 루비 명령을 실행하여 정상 동작 여부를 확인합니다.\n1$ ruby --version 2. Fluentd 설치 Fluentd 소스코드를 github에서 clone 받습니다.\n1$ git clone -b v1.15.3 https://github.com/fluent/fluentd.git 클론 받은 소스코드 디렉토리로 이동한 후 bundle install 명령으로 Fluentd 소스에 필요한 RubyGem들을 세팅합니다.\n1$ cd fleuntd 2$ bundle install 의존성 세팅이 완료되면 아래의 명령으로 소스를 빌드합니다.\n1$ bundle exec rake build 빌드가 성공하면 pkg 디렉토리에 gem 파일이 생성됩니다. 이 gem을 아래 명령으로 설치합니다.\n1$ sudo gem install pkg/fluentd-v1.15.3.gem gem 설치가 끝나면 Fluentd 설치는 마무리 됩니다. 아래의 명령으로 Fluentd 설정 파일을 생성해줍니다.\n1$ fluentd --setup /etc/fluent 마지막으로 아래 명령으로 Fluentd를 실행하여 정상 동작하는지 확인합니다.\n1$ fluentd -c /etc/fluent/fluentd.conf -vv \u0026amp; Fluentd를 종료하려면 pkill 명령으로 종료시킬 수 있습니다.\n1$ sudo pkill -f fluentd 설치 이후 작업 1. systemd에 Fluentd 서비스 등록하기(Optional) Fluentd를 systemd 데몬으로 관리되는 서비스로 추가하기 위한 작업입니다. 필수 절차는 아니며 선택사항 입니다.\nfluentd 유저를 생성해서 시스템 유저로 등록합니다.\n1$ sudo adduser --system --shell /bin/bash --no-create-home fluentd fluentd 그룹을 생성합니다.\n1$ sudo addgroup --group fluentd fleuntd 유저를 fluentd 그룹에 추가합니다.\n1$ sudo usermod -aG fluentd fluentd Fluentd 워킹디렉토리의 소유를 fleuntd 유저와 그룹으로 변경합니다.\n1$ sudo chown -R fluentd:fluentd /etc/fluentd Fluentd 로깅디렉토리를 만들고 소유를 fluentd 유저와 그룹으로 변경합니다.\n1$ sudo mkdir /var/log/fluentd 2$ sudo chown -R fluentd:fluentd /var/log/fluentd Fluentd 서비스 등록을 위해 systemd 스크립트를 작성합니다.\n1$ sudo vi /etc/systemd/system/fluentd.service 1[Unit] 2Description=Fluentd 3Documentation=http://www.fluentd.org/ 4Wants=network-online-target 5After=network-online-target 6 7[Service] 8Type=forking 9RuntimeDirectory=data 10WorkingDirectory=/etc/fleuntd 11ExecStart=/usr/local/bin/fluentd -c /etc/fluentd/fluent.conf -o /var/log/fluentd/fluent.log -d /etc/fluentd/fluent.pid 12User=fluentd 13Group=fluentd 14StandardOutput=journal 15StandardError=inherit 16TimeoutStartSec=75 17TimeoutStopSec=0 18KillSignal=SIGTERM 19KillMode=process 20SendSIGKILL=no 21SuccessExitStatus=143 22 23[Install] 24WantedBy=multi-user.target 새로 작성한 Fluentd 서비스 스크립트를 systemd 데몬에 반영합니다.\n1$ sudo systemctl daemon-reload Fluentd 서비스를 활성화 합니다.\n1$ sudo systemctl enable fluentd.service 이제 Fluentd 서비스를 systemctl로 시작할 수 있습니다.\n1$ sudo systemctl start fluentd 마지막으로 서비스 시작 후 상태를 조회해보고 정상 동작 여부를 확인합니다.\n1$ sudo systemctl status fluentd ","link":"https://thouy.github.io/posts/logging/fluentd_install/","section":"posts","tags":null,"title":"Fluentd Install"},{"body":"","link":"https://thouy.github.io/posts/web/","section":"posts","tags":["web"],"title":"Web"},{"body":"등장배경 과거에는 클라이언트-서버간 양방향 통신이 필요한 웹 애플리케이션을 만들기 위해서는, HTTP가 남용될 수 밖에 없었습니다. 왜냐하면 upstream, downstream을 별도의 HTTP 연결로 전송해야 했기 때문입니다. 이로 인해 다양한 문제들이 발생하게 됩니다.\n서버는 클라이언트별로 복수 개의 TCP 연결을 사용해야만 합니다. (하나는 클라이언트로 메세지를 보내기 위한 연결, 다른 하나는 upstream을 받기위한 연결) 결국 높은 오버헤드를 발생시키게 됩니다. 클라이언트는 서버로부터 온 메세지에 대한 응답을 위해서 서버와의 커넥션을 유지 및 관리해야 합니다. 이러한 문제를 해소하기 위해 WebSocket 프로토콜이 등장합니다.\n개요 WebSocket은 WebSocket API(WSAPI)와 결합하여, Single TCP 연결로 클라이언트-서버간의 양방향 통신을 제공합니다. WebSocket은 HTTP 위에서 작동하도록 설계되어 80과 443 포트를 HTTP와 동일하게 사용합니다. WebSocket 프로토콜은 handshake, data transfer 두가지 파트로 구분됩니다.\nHandshake 파트 아래는 클라이언트가 서버로 보내는 handshake 요청 HTTP 헤더입니다.\n1GET /chat HTTP/1.1 2 Host: server.example.com 3 Upgrade: websocket 4 Connection: Upgrade 5 Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== 6 Origin: http://example.com 7 Sec-WebSocket-Protocol: chat, superchat 8 Sec-WebSocket-Version: 13 Upgrade : 프로토콜 전환을 위해 사용하는 헤더입니다. 웹소켓 요청 시에는 반드시 websocket이라는 값을 가집니다. Connection : 현재의 전송이 완료된 후 네트워크 접속을 유지할지 말지를 제어합니다. 웹소켓 요청 시에는 반드시 Upgrade라는 값으로 세팅되어야 합니다. Sec-WebSocket-Key : 유효한 웹소켓 요청인지 확인하기 위해 사용하는 키 입니다. Sec-WebSocket-Protocol : 사용하고자 하는 하나 이상의 웹 소켓 프로토콜을 지정합니다. (Optional) Sec-WebSocket-Version : 클라이언트가 사용하고자 하는 웹소켓 프로토콜 버전을 지정합니다. Origin : CORS에 활용되는 헤더입니다. 아래는 서버가 클라이언트의 handshake에 대해 101코드로 응답하는 헤더 입니다. 101코드는 WebSocket 프로토콜의 전환을 서버가 승인했음을 의미합니다.\n1HTTP/1.1 101 Switching Protocols 2 Upgrade: websocket 3 Connection: Upgrade 4 Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= 5 Sec-WebSocket-Protocol: chat Data Transfer 파트 Handshake 후에 웹소켓이 연결되면, 데이터 전송파트가 시작됩니다. 이 때부터 서버와 클라이언트는 메세지를 전송할 수 있으며, 이 메세지를 프레임이라고 부릅니다. 웹소켓 프레임의 헤더의 OPCODE(Operate Code) 값으로 프레임의 유형이 결정됩니다. OPCODE별 의미는 아래와 같습니다.\nOPCODE Meaning 0 Continuation 1 Text (UTF-8) 2 Binary 3-7 Reserved for further non-control frames 8 Connection close 9 Ping 10 Pong 11-15 Reserved for further non-control frames Close OPCODE(8)의 프레임을 전송하면 웹소켓 연결이 종료됩니다.\n","link":"https://thouy.github.io/posts/web/websocket/","section":"posts","tags":null,"title":"Websocket"},{"body":"","link":"https://thouy.github.io/posts/etc/","section":"posts","tags":["etc"],"title":"ETC"},{"body":"개요 Hugo로 Github 블로그를 생성하는 내용을 소개하고자 합니다. Ubuntu 20.04.5 LTS 환경에서 진행했습니다.\n준비물 Go 1.18 버전 이상 gcc 컴파일러 블로그 파일을 업로드할 Github 레퍼지토리 (레퍼지토리 이름은 Github_유저명.github.io 형태로 지정해주세요) 설치 1. Hugo 소스 빌드하기 Github에서 Hugo 소스코드를 clone 받아서 go로 빌드합니다.\n1$ go install -tags extended github.com/gohugoio/hugo@latest 2$ hugo version hugo version 명령으로 버전 내용이 잘 출력되면 Hugo 설치는 마무리 됩니다.\n2. Hugo로 블로그 프로젝트 생성하기 hugo 명령으로 새로운 site를 생성합니다.\n1$ hugo new site hugo_log 2Congratulations! Your new Hugo site is created in /home/thouy/test/test_log. 3 4Just a few more steps and you\u0026#39;re ready to go: 5 61. Download a theme into the same-named folder. 7 Choose a theme from https://themes.gohugo.io/ or 8 create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 92. Perhaps you want to add some content. You can add single files 10 with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 113. Start the built-in live server via \u0026#34;hugo server\u0026#34;. 12 13Visit https://gohugo.io/ for quickstart guide and full documentation. new site 명령이 실행되면 아래 구조와 같은 디렉토리와 파일들이 자동으로 생성됩니다.\n1example/ 2├── archetypes/ 3│ └── default.md 4├── assets/ 5├── content/ 6├── data/ 7├── layouts/ 8├── public/ 9├── static/ 10├── themes/ 11└── config.toml 3. config 디렉토리 생성 설정을 체계적으로 관리하기 위해 config 디렉토리를 세팅합니다. Hugo의 기본 config 디렉토리 구조는 아래와 같습니다. 아래와 같은 구조로 디렉토리와 파일을 세팅합니다.\n1├── config 2│ └── _default 3│ ├── config.toml 4│ ├── languages.toml 5│ ├── menus.en.toml 6│ ├── menus.zh.toml 7│ └── params.toml 디렉토리 구조를 만들어 설정을 관리하는 목적은 용도별로 설정을 체계적으로 관리하기 위함입니다. 굳이 필요하지 않다면 그냥 config.toml, params,toml, menus.toml 파일을 블로그 루트 디렉토리에 생성하여 사용하셔도 무방합니다.\n2. Hugo 테마 설치 https://themes.gohugo.io/ 에서 Hugo 테마를 골라 설치합니다. 이 글에서는 hugo-clarity 테마로 설치를 진행합니다.\nhttps://themes.gohugo.io/themes/hugo-clarity/\n맨 처음 생성했던 블로그 소스 루트 디렉토리로 이동하여 hugo-clarity를 git 서브모듈로 등록합니다.\n1$ cd hugo_log 2$ git init 3$ git submodule add https://github.com/chipzoller/hugo-clarity themes/hugo-clarity config 설정하기 1. config.toml config/_default/config.toml을 열어 항목들을 설정합니다.\n1baseURL = \u0026#39;https://thouy.github.io/\u0026#39; 2languageCode = \u0026#39;en-us\u0026#39; 3title = \u0026#39;KMS Dev log\u0026#39; 4theme = \u0026#39;hugo-clarity\u0026#39; 5paginate = 10 2. params.toml config/_default/params.toml을 열어 항목들을 설정합니다.\n1enableSearch = true 2codeLineNumbers = true 3codeMaxLines = 15 4 5[author] 6name = \u0026#34;Min soo, Kim\u0026#34; 3. menu.toml config/_default/menu.toml을 열어 항목들을 설정합니다.\n1[[main]] 2 name = \u0026#34;Home\u0026#34; 3 url = \u0026#34;\u0026#34; 4 weight = -110 5 6[[main]] 7 name = \u0026#34;Archives\u0026#34; 8 url = \u0026#34;post/rich-content/\u0026#34; 9 weight = -109 10 11# Submenus are done this way: parent -\u0026gt; identifier 12[[main]] 13 name = \u0026#34;Links\u0026#34; 14 identifier = \u0026#34;Links\u0026#34; 15 weight = -108 16[[main]] 17 parent = \u0026#34;Links\u0026#34; 18 name = \u0026#34;LinkedIn\u0026#34; 19 url = \u0026#34;https://www.linkedin.com/\u0026#34; 20[[main]] 21 parent = \u0026#34;Links\u0026#34; 22 name = \u0026#34;Twitter\u0026#34; 23 url = \u0026#34;https://twitter.com/\u0026#34; 24 25[[main]] 26 name = \u0026#34;About\u0026#34; 27 url = \u0026#34;about/\u0026#34; 28 weight = -107 29 30# social menu links 31 32[[social]] 33 name = \u0026#34;github\u0026#34; 34 type = \u0026#34;social\u0026#34; 35 weight = 1 36 url = \u0026#34;https://github.com/#\u0026#34; 37[[social]] 38 name = \u0026#34;twitter\u0026#34; 39 weight = 2 40 url = \u0026#34;https://twitter.com/#\u0026#34; 41[[social]] 42 name = \u0026#34;linkedin\u0026#34; 43 weight = 3 44 url = \u0026#34;https://www.linkedin.com/in/#\u0026#34; 더 상세한 설정 내용은 https://gohugo.io/getting-started/configuration/ 를 참고해주세요.\n새 포스트 작성하기 블로그 루트 디렉토리에서 아래의 명령으로 새 포스트 문서 마크다운을 생성합니다.\n1$ hugo new post/hello_world.md 명령이 실행되면 content/post 디렉토리 안에 hello_world.md 파일이 생성됩니다. hello_world.md 파일을 열어 마크다운 문법으로 글을 작성합니다.\n1--- 2title: \u0026#34;Hello_world\u0026#34; 3date: 2023-01-19T11:37:43+09:00 4draft: true 5--- 6 7## Hello world!! Hugo server 명령으로 새 포스트가 잘 나오는지 확인합니다. draft: true로 되어 있으므로 -D 플래그를 꼭 넣어서 명령을 실행해줍니다.\n1$ hugo server -D 브라우저에서 localhost:1313으로 접속하면 아래 화면처럼 새 포스트가 추가된 걸 확인할 수 있습니다. 빌드 및 배포하기 1. 빌드 새 글이 정상적으로 보인다면 이제 빌드를 할 차례입니다. 블로그 루트 디렉토리로 이동하여 아래 명령으로 빌드합니다. draft가 활성화된 상태이기 때문에 -D 플래그를 넣어 빌드합니다.\n1$ hugo -D 2Start building sites … 3hugo v0.110.0-e32a493b7826d02763c3b79623952e625402b168+extended linux/amd64 BuildDate=2023-01-17T12:16:09Z VendorInfo=snap:0.110.0 4 5 | EN 6-------------------+----- 7 Pages | 7 8 Paginator pages | 0 9 Non-page files | 0 10 Static files | 57 11 Processed images | 0 12 Aliases | 3 13 Sitemaps | 1 14 Cleaned | 0 15 16Total in 61 ms 빌드가 완료되면 public 디렉토리에 html을 포함한 여러가지 파일들이 생성됩니다. 이제 이 파일들을 github에 푸시하여 배포하면 끝납니다. 푸시한 후에 레포지토리명을 브라우저 주소창에 입력하여 접속하면 배포된 블로그를 확인할 수 있습니다.\n푸시하면 배포까지는 1분 가량이 시간이 소요되니 1분 후 다시 시도하면 블로그 화면을 보실 수 있습니다.\n","link":"https://thouy.github.io/posts/etc/hugo_github_blog/","section":"posts","tags":null,"title":"Hugo로 Github 블로그 생성하기"},{"body":"개요 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말합니다. 일반적으로 프로그램은 하나의 스레드를 가지지만, 프로그램에 따라서 둘 이상의 스레드를 동시에 실행할 수도 있습니다. 이러한 방식을 멀티스레드(Multithread) 라고 합니다.\n웹서버의 멀티스레드 예시 Dispatcher 스레드가 네트워크를 통해 외부에서 전송된 리퀘스트(request)를 읽어옵니다. 리퀘스트를 읽어온 후에, Worker 스레드를 깨워 리퀘스트를 처리하도록 합니다. Worker 스레드가 깨어나면 리퀘스트가 웹 페이지 캐시로 처리가 가능한지 확인합니다. 만약 캐시로 처리할 수 없는 리퀘스트라면 디스크에서 필요한 데이터를 로드하게 되는데, 디스크 작업이 완료될 때까지 Worker 스레드는 block 됩니다. Worker 스레드가 block 되면 다른 Worker 스레드를 실행합니다. 스레드의 종류 스레드는 사용자의 애플리케이션에서 관리하는 유저 레벨 스레드와 OS의 커널에서 관리하는 커널 레벨 스레드가 있습니다. User-Level Threads (ULTs) 유저 레벨 스레드는 라이브러리(런타임 시스템)를 통해 스레드를 이용하는 것을 의미합니다. 일반적으로 #include 혹은 import 구문을 이용하여 라이브러리를 로드한 후 활용하는 방식입니다. 유저 레벨 스레드는 메모리의 사용자 영역(User space)에서 연산을 수행합니다.\n장점 커널의 개입없이 스레드 생성, 스레드 간 전환, 스레드 간 동기화가 수행됩니다. 즉, 스케쥴링과 동기화를 위해 커널을 호출(System Call)하지 않기 때문에 오버헤드가 적습니다. 스케쥴링, 동기화를 위한 System Call이 호출되지 않으므로 유저모드와 커널모드 간의 전환이 발생하지 않습니다. 단점 커널에 의해 관리되지 않기 때문에 시스템 전반에 걸친 스케쥴링 우선순위를 지원하지 않습니다. 디스크 I/O 작업과 같이 System Call(커널 호출)이 필요한 작업이 발생하면 커널은 유저 레벨 스레드의 존재를 모르기 때문에 모든 다른 스레드가 중단됩니다. Kernel-Level Threads (KLTs) 커널 레벨 스레드는 운영체제가 지원하는 스레드 기능으로 구현됩니다. 커널에 의해 스레드 생성과 스케쥴링이 관리됩니다. 커널 레벨 스레드는 메모리의 커널 영역(Kernel space)에서 연산을 수행합니다. 하나의 프로세스는 적어도 하나의 커널 스레드를 가집니다.\n장점 커널이 직접 스레드 관리에 관여하기 때문에 시스템 전반에 걸친 스케쥴링에 있어 유리합니다. 동작중인 커널 스레드가 I/O 작업을 위해 System Call을 호출해도 다른 스레드에 영향을 주지 않습니다. 단점 스케쥴링과 동기화를 위해 System Call을 호출하게 되는데 이 때의 처리 비용이 많이 소요됩니다. System Call이 호출되면 메모리의 유저 모드에서 커널 모드로의 전환이 빈번히 발생되고 성능 저하가 발생됩니다. ","link":"https://thouy.github.io/posts/etc/thread/","section":"posts","tags":null,"title":"[OS] 스레드(Thread)"},{"body":"고루틴(Goroutine)은 Go 런타임이 관리하는 경량쓰레드입니다. 이번 포스팅에서는 OS 레벨의 쓰레드와 고루틴이 어떠한 차이가 있는지 살펴보고자 합니다.\n[OS] 스레드(Thread)\n메모리 점유 측면 고루틴은 생성 시 약 2KB의 스택 메모리 공간을 소모합니다. 필요에 따라 힙 메모리를 사용하기도 합니다. 쓰레드는 쓰레드가 사용할 메모리 공간과 더불어 Guard Page로 불리는 쓰레드와 쓰레드 사이의 메모리 공간까지 포함하기 때문에 약 1MB의 메모리 공간을 소모합니다. 때문에 쓰레드를 생성하면 할수록 가용 힙 메모리 공간이 계속 줄어드는 문제점이 있습니다. 생성 및 소거 비용 측면 고루틴은 Go 런타임이 논리적으로 생성하고 소거되므로 생성/소거에 드는 비용이 저렴합니다. 쓰레드는 OS로부터 생성에 필요한 리소스 요청을 통해 생성합니다. 쓰레드 작업이 완료되면 해당 리소스를 다시 OS에 반환해야 합니다. 이 과정이 많은 비용을 요구합니다. 이런 문제를 해소하기 위해 쓰레드 풀을 사용하기도 합니다. Context Switching 비용 Context Switching(문맥 교환)은 현재 진행중인 Task(프로세스나 쓰레드)의 상태를 저장하고 다음 진행할 Task의 상태를 읽어 적용하는 과정을 말합니다. 쓰레드가 교체되어 Context Switching이 진행되면 16개의 범용 레지스터, PC(Program Counter), SP(Stack Pointer), Segment 레지스터 등에서 save/restore 작업이 진행됩니다. 이 같은 작업을 처리하기 때문에 Context Switching 시 많은 비용을 소모하게 됩니다. 고루틴은 3개의 레지스터(PC, SP, DX)만 save/restore 작업을 처리하기 때문에 상대적으로 쓰레드보다 적은 비용을 소모합니다. ","link":"https://thouy.github.io/posts/golang/goroutine_versus_thread/","section":"posts","tags":null,"title":"[Golang] Goroutine VS Thread"},{"body":"","link":"https://thouy.github.io/posts/golang/","section":"posts","tags":["golang"],"title":"Golang"},{"body":"Goroutine(고루틴) 고루틴은 Go 런타임이 관리하는 가상쓰레드 입니다. Go에서 go 키워드를 사용하여 함수를 호출하면, Go는 런타임시에 새로운 고루틴을 생성합니다. 고루틴은 비동기적으로 함수를 실행하므로, 여러 함수를 동시에 실행하고자 할 때 사용됩니다. 고루틴은 OS의 쓰레드보다 더 가볍게 비동기 동시처리를 구현하기 위해 만들어 졌습니다. 때문에 고루틴은 OS의 쓰레드와 1:1로 대응되지 않고 훨씬 적은 OS의 쓰레드를 사용합니다. Go 런타임이 실행하는 모든 프로그램은 고루틴을 기반으로 동작합니다. main 함수도 고루틴으로 실행됩니다. 때문에 모든 Go 프로그램은 적어도 하나의 (메인)고루틴을 포함합니다.\nGoroutine VS Thread\n1package main 2 3func hello(name string) { 4\tfmt.Printf(\u0026#34;%s says hello.\u0026#34;, name) 5} 6 7func main() { 8 go hello(\u0026#34;Alice\u0026#34;) 9 go hello(\u0026#34;Bob\u0026#34;) 10 go hello(\u0026#34;James\u0026#34;) 11 go hello(\u0026#34;Sophia\u0026#34;) 12} WaitGroup Go 프로그램은 main함수 (main고루틴)가 종료되면 모든 (sub)고루틴들도 강제로 종료됩니다. 때문에 메인고루틴은 모든 서브고루틴이 다 실행됐을 때까지 기다려줘야 하는데 이때 WaitGroup을 사용합니다. WaitGroup은 서브고루틴이 종료될 때까지 메인고루틴이 먼저 종료되지 않도록 해줍니다.\n1package main 2 3var wg sync.WaitGroup 4 5func hello(name string) { 6\tdefer wg.Done() 7\tfmt.Printf(\u0026#34;%s says hello.\u0026#34;, name) 8} 9func bye(name string) { 10\tdefer wg.Done() 11\tfmt.Printf(\u0026#34;%s says hello.\u0026#34;, name) 12} 13 14func main() { 15 wg.add(2) 16\tgo hello(\u0026#34;Alice\u0026#34;) 17 go bye(\u0026#34;Bob\u0026#34;) 18 wg.Wait() 19} WaitGroup을 사용하기 위해서 먼저 Add() 함수로 대기해야 하는 고루틴의 개수를 지정합니다. 그리고 각 고루틴에서 Done()을 호출하도록 합니다. main()에서는 Wait()를 호출하여 각 고루틴에서 Done()이 모두 호출될 때까지 기다리도록 합니다.\n채널(Channel) 채널은 고루틴간에 데이터를 주고 받는 통로입니다. 채널은 make() 함수를 통해 미리 생성되어야 하며, \u0026lt;- 연산자를 이용하여 채널로 데이터를 보내거나 받을 수 있습니다. 채널은 비동기로 동작하는 고루틴을 동기로 제어하기 위한 목적으로 활용되기도 합니다. 채널에는 수신자와 송신자가 서로를 기다리는 속성이 있기 때문입니다.\n1package main 2 3var wg sync.WaitGroup 4func main() { 5\twg.Add(4) 6\tch := make(chan int) 7\tgo func() { 8\tfmt.Print(\u0026#34;I \u0026#34;) 9\ttime.Sleep(1 * time.Second) 10\tch \u0026lt;- 1 11\twg.Done() 12\t}() 13\t\u0026lt;-ch 14\tgo func() { 15\tfmt.Print(\u0026#34;am \u0026#34;) 16\ttime.Sleep(1 * time.Second) 17\tch \u0026lt;- 2 18\twg.Done() 19\t}() 20\t\u0026lt;-ch 21\tgo func() { 22\tfmt.Print(\u0026#34;Iron \u0026#34;) 23\ttime.Sleep(1 * time.Second) 24\tch \u0026lt;- 3 25\twg.Done() 26\t}() 27\t\u0026lt;-ch 28\tgo func() { 29\tfmt.Print(\u0026#34;Man\u0026#34;) 30\ttime.Sleep(1 * time.Second) 31\tch \u0026lt;- 4 32\twg.Done() 33\t}() 34\t\u0026lt;-ch 35 36\twg.Wait() 위의 코드에서는 4개의 익명함수로 된 서브고루틴이 다 실행되고 메인고루틴이 종료되도록 WaitGroup을 사용했습니다. 4개의 서브고루틴을 순차적으로 제어하기 위해, 채널에 데이터를 넣고 빼는 코드를 삽입했습니다. 코드를 실행하면 맨 처음 익명함수부터 메인고루틴과 데이터를 주고 받으며 순차적으로 실행됩니다. 익명함수에서 채널로 데이터를 보내면 다른 서브고루틴은 채널에서 데이터를 꺼낼때까지 블로킹 됩니다. 메인고루틴에서 채널로부터 데이터를 꺼내면 이후 다음 서브고루틴이 실행됩니다.\n채널 버퍼링 Go 채널은 Unbuffered Channel과 Buffered Channel 두가지가 있습니다.\nUnbuffered Channel make()로 채널을 생성할 때, 버퍼 개수를 지정하지 않고 생성하면 Unbuffered Channel이 만들어 집니다. Unbuffered Channel은 하나의 수신자가 데이터를 받을 때까지 송신자는 데이터를 보낸 채널에 블로킹 됩니다.\nBuffered Channel make()로 채널을 생성할 때, 버퍼 개수를 지정하고 생성하면 Buffered Channel이 만들어 집니다. Buffered Channel은 수신자가 데이터를 받을 때까지 송신자가 블로킹 되지 않고 다른 작업을 계속 수행할 수 있습니다. 채널의 버퍼가 가득차면 송신자는 블로킹 되며 수신자가 데이터를 꺼낼 때까지 대기합니다.\n채널 close() 채널을 생성해서 데이터를 주고 받은 와중에 close()함수로 채널을 닫을 수 있습니다. 채널을 닫게 되면 해당 채널로 더이상 데이터를 보낼 수 없습니다. 하지만 계속 수신은 받을 수 있습니다. close() 함수는 채널로 루프를 돌리고자 할 때 활용될 수 있습니다.\n채널 range문 for range문으로 채널을 사용하면 for 루프는 채널이 닫힐 때까지 루프를 실행하다가 채널이 닫히면 루프를 종료합니다.\n1\tfor i := range ch { 2 fmt.Println(i) 3 } ","link":"https://thouy.github.io/posts/golang/goroutine_and_channel/","section":"posts","tags":null,"title":"[Golang] Goroutine \u0026 Channel"},{"body":"호이스팅이란 Hoist는 사전적으로 무거운 물건 및 무언가를 기계 등을 이용하여 위로 끌어 올리는 것(lift)을 의미합니다. 자바스크립트에서 호이스팅은 자바스크립트 Parser가 변수나 함수를 끌어 올려 최상단에 배치하는 것을 말합니다.\n실제로 코드가 상단으로 올라가는 것은 아닙니다. 자바스크립트 Parser가 내부적으로 최상단에 끌어 올려서 처리하게 되며, 이 때 메모리 상의 변화는 없습니다.\n호이스팅 대상 자바스크립트는 선언 구문만 호이스팅 합니다. 때문에 변수 선언 없이 먼저 변수를 사용하게 되더라도 예외가 발생하지 않습니다. 다만 그 변수는 사용되는 시점에 자동으로 기본 초기화 상태 (var 선언의 경우 undefined)가 됩니다.\n자동으로 undefined 초기화가 되는 경우는 var 선언에만 해당됩니다.\n아래의 코드를 실행하면 message에는 undefined가 출력됩니다.\n1console.log(message); // undefined 출력 2var message; // 이 구문은 파서에 의해 호이스팅 됩니다. 3message = \u0026#39;hoisting\u0026#39;; // 변수에 값 할당 하지만 선언 구문이 없으면 호이스팅이 발생하지 않기 때문에 변수를 읽을 때 예외가 발생합니다.\n1console.log(message); // ReferenceError 예외 발생 2message = \u0026#39;hoisting\u0026#39;; 호이스팅은 함수 선언에도 적용됩니다. 아래와 같이 함수를 먼저 호출하고 아래에 함수를 선언해도 파서에 의해 함수 선언은 상단으로 호이스팅 되기 때문에, 정상적으로 함수가 호출됩니다.\n1showMessage(\u0026#39;hoisting\u0026#39;); 2 3function showMessage(message) { 4 console.log(\u0026#34;Message : \u0026#34; + message); 5} 호이스팅 시 예외 상황 let과 const let과 const로 선언한 변수도 호이스팅 대상이지만, var와 달리 호이스팅 시 undefined로 변수가 초기화 되지는 않습니다. 때문에 변수 초기화 전에 변수를 읽으려고 하게 되면 예외가 발생됩니다.\n함수 표현식 변수에 함수를 할당하는 형태인 함수 표현식은 호이스팅 되지 않습니다.\n1showMessage(\u0026#39;hoisting\u0026#39;); // Uncaught TypeError: showMessage is not a function 발생 2var showMessage = function(message) { 3 console.log(\u0026#34;Message : \u0026#34; + message); 4} 아래는 Arrow function으로 함수 표현식을 작성한 코드입니다.\n1showMessage(\u0026#39;hoisting\u0026#39;); // Uncaught TypeError: showMessage is not a function 발생 2var showMessage = message =\u0026gt; console.log(\u0026#34;Message : \u0026#34; + message); ","link":"https://thouy.github.io/posts/javascript/hoisting/","section":"posts","tags":null,"title":"[Javascript] Hoisting (호이스팅)"},{"body":"","link":"https://thouy.github.io/posts/javascript/","section":"posts","tags":["javascript"],"title":"Javascript"},{"body":"","link":"https://thouy.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://thouy.github.io/tags/etc/","section":"tags","tags":null,"title":"etc"},{"body":"","link":"https://thouy.github.io/tags/golang/","section":"tags","tags":null,"title":"golang"},{"body":"","link":"https://thouy.github.io/tags/javascript/","section":"tags","tags":null,"title":"javascript"},{"body":"","link":"https://thouy.github.io/tags/logging/","section":"tags","tags":null,"title":"logging"},{"body":"","link":"https://thouy.github.io/series/","section":"series","tags":null,"title":"Series"},{"body":"","link":"https://thouy.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://thouy.github.io/tags/web/","section":"tags","tags":null,"title":"web"}]