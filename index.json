[{"body":"고루틴(Goroutine)은 Go 런타임이 관리하는 경량쓰레드입니다. 이번 포스팅에서는 OS 레벨의 쓰레드와 고루틴이 어떠한 차이가 있는지 살펴보고자 합니다.\n[OS] 스레드(Thread)\n메모리 점유 측면 고루틴은 생성 시 약 2KB의 스택 메모리 공간을 소모합니다. 필요에 따라 힙 메모리를 사용하기도 합니다. 쓰레드는 쓰레드가 사용할 메모리 공간과 더불어 Guard Page로 불리는 쓰레드와 쓰레드 사이의 메모리 공간까지 포함하기 때문에 약 1MB의 메모리 공간을 소모합니다. 때문에 쓰레드를 생성하면 할수록 가용 힙 메모리 공간이 계속 줄어드는 문제점이 있습니다. 생성 및 소거 비용 측면 고루틴은 Go 런타임이 논리적으로 생성하고 소거되므로 생성/소거에 드는 비용이 저렴합니다. 쓰레드는 OS로부터 생성에 필요한 리소스 요청을 통해 생성합니다. 쓰레드 작업이 완료되면 해당 리소스를 다시 OS에 반환해야 합니다. 이 과정이 많은 비용을 요구합니다. 이런 문제를 해소하기 위해 쓰레드 풀을 사용하기도 합니다. Context Switching 비용 Context Switching(문맥 교환)은 현재 진행중인 Task(프로세스나 쓰레드)의 상태를 저장하고 다음 진행할 Task의 상태를 읽어 적용하는 과정을 말합니다. 쓰레드가 교체되어 Context Switching이 진행되면 16개의 범용 레지스터, PC(Program Counter), SP(Stack Pointer), Segment 레지스터 등에서 save/restore 작업이 진행됩니다. 이 같은 작업을 처리하기 때문에 Context Switching 시 많은 비용을 소모하게 됩니다. 고루틴은 3개의 레지스터(PC, SP, DX)만 save/restore 작업을 처리하기 때문에 상대적으로 쓰레드보다 적은 비용을 소모합니다. ","link":"https://thouy.github.io/posts/golang/goroutine_versus_thread/","section":"posts","tags":null,"title":"[Golang] Goroutine VS Thread"},{"body":"","link":"https://thouy.github.io/posts/golang/","section":"posts","tags":["index"],"title":"Golang"},{"body":"","link":"https://thouy.github.io/","section":"","tags":null,"title":"KMS Dev log"},{"body":"","link":"https://thouy.github.io/posts/","section":"posts","tags":null,"title":"Posts"},{"body":"Goroutine(고루틴) 고루틴은 Go 런타임이 관리하는 가상쓰레드 입니다. Go에서 go 키워드를 사용하여 함수를 호출하면, Go는 런타임시에 새로운 고루틴을 생성합니다. 고루틴은 비동기적으로 함수를 실행하므로, 여러 함수를 동시에 실행하고자 할 때 사용됩니다. 고루틴은 OS의 쓰레드보다 더 가볍게 비동기 동시처리를 구현하기 위해 만들어 졌습니다. 때문에 고루틴은 OS의 쓰레드와 1:1로 대응되지 않고 훨씬 적은 OS의 쓰레드를 사용합니다. Go 런타임이 실행하는 모든 프로그램은 고루틴을 기반으로 동작합니다. main 함수도 고루틴으로 실행됩니다. 때문에 모든 Go 프로그램은 적어도 하나의 (메인)고루틴을 포함합니다.\nGoroutine VS Thread\n1package main 2 3func hello(name string) { 4\tfmt.Printf(\u0026#34;%s says hello.\u0026#34;, name) 5} 6 7func main() { 8\tgo hello(\u0026#34;Alice\u0026#34;) 9 go hello(\u0026#34;Bob\u0026#34;) 10 go hello(\u0026#34;James\u0026#34;) 11 go hello(\u0026#34;Sophia\u0026#34;) 12} WaitGroup Go 프로그램은 main함수 (main고루틴)가 종료되면 모든 (sub)고루틴들도 강제로 종료됩니다. 때문에 메인고루틴은 모든 서브고루틴이 다 실행됐을 때까지 기다려줘야 하는데 이때 WaitGroup을 사용합니다. WaitGroup은 서브고루틴이 종료될 때까지 메인고루틴이 먼저 종료되지 않도록 해줍니다.\n1package main 2 3var wg sync.WaitGroup 4 5func hello(name string) { 6\tdefer wg.Done() 7\tfmt.Printf(\u0026#34;%s says hello.\u0026#34;, name) 8} 9func bye(name string) { 10\tdefer wg.Done() 11\tfmt.Printf(\u0026#34;%s says hello.\u0026#34;, name) 12} 13 14func main() { 15 wg.add(2) 16\tgo hello(\u0026#34;Alice\u0026#34;) 17 go bye(\u0026#34;Bob\u0026#34;) 18 wg.Wait() 19} WaitGroup을 사용하기 위해서 먼저 Add() 함수로 대기해야 하는 고루틴의 개수를 지정합니다. 그리고 각 고루틴에서 Done()을 호출하도록 합니다. main()에서는 Wait()를 호출하여 각 고루틴에서 Done()이 모두 호출될 때까지 기다리도록 합니다.\n채널(Channel) 채널은 고루틴간에 데이터를 주고 받는 통로입니다. 채널은 make() 함수를 통해 미리 생성되어야 하며, \u0026lt;- 연산자를 이용하여 채널로 데이터를 보내거나 받을 수 있습니다. 채널은 비동기로 동작하는 고루틴을 동기로 제어하기 위한 목적으로 활용되기도 합니다. 채널에는 수신자와 송신자가 서로를 기다리는 속성이 있기 때문입니다.\n1package main 2 3var wg sync.WaitGroup 4func main() { 5\twg.Add(4) 6\tch := make(chan int) 7\tgo func() { 8\tfmt.Print(\u0026#34;I \u0026#34;) 9\ttime.Sleep(1 * time.Second) 10\tch \u0026lt;- 1 11\twg.Done() 12\t}() 13\t\u0026lt;-ch 14\tgo func() { 15\tfmt.Print(\u0026#34;am \u0026#34;) 16\ttime.Sleep(1 * time.Second) 17\tch \u0026lt;- 2 18\twg.Done() 19\t}() 20\t\u0026lt;-ch 21\tgo func() { 22\tfmt.Print(\u0026#34;Iron \u0026#34;) 23\ttime.Sleep(1 * time.Second) 24\tch \u0026lt;- 3 25\twg.Done() 26\t}() 27\t\u0026lt;-ch 28\tgo func() { 29\tfmt.Print(\u0026#34;Man\u0026#34;) 30\ttime.Sleep(1 * time.Second) 31\tch \u0026lt;- 4 32\twg.Done() 33\t}() 34\t\u0026lt;-ch 35 36\twg.Wait() 위의 코드에서는 4개의 익명함수로 된 서브고루틴이 다 실행되고 메인고루틴이 종료되도록 WaitGroup을 사용했습니다. 4개의 서브고루틴을 순차적으로 제어하기 위해, 채널에 데이터를 넣고 빼는 코드를 삽입했습니다. 코드를 실행하면 맨 처음 익명함수부터 메인고루틴과 데이터를 주고 받으며 순차적으로 실행됩니다. 익명함수에서 채널로 데이터를 보내면 다른 서브고루틴은 채널에서 데이터를 꺼낼때까지 블로킹 됩니다. 메인고루틴에서 채널로부터 데이터를 꺼내면 이후 다음 서브고루틴이 실행됩니다.\n채널 버퍼링 Go 채널은 Unbuffered Channel과 Buffered Channel 두가지가 있습니다.\nUnbuffered Channel make()로 채널을 생성할 때, 버퍼 개수를 지정하지 않고 생성하면 Unbuffered Channel이 만들어 집니다. Unbuffered Channel은 하나의 수신자가 데이터를 받을 때까지 송신자는 데이터를 보낸 채널에 블로킹 됩니다.\nBuffered Channel make()로 채널을 생성할 때, 버퍼 개수를 지정하고 생성하면 Buffered Channel이 만들어 집니다. Buffered Channel은 수신자가 데이터를 받을 때까지 송신자가 블로킹 되지 않고 다른 작업을 계속 수행할 수 있습니다. 채널의 버퍼가 가득차면 송신자는 블로킹 되며 수신자가 데이터를 꺼낼 때까지 대기합니다.\n채널 close() 채널을 생성해서 데이터를 주고 받은 와중에 close()함수로 채널을 닫을 수 있습니다. 채널을 닫게 되면 해당 채널로 더이상 데이터를 보낼 수 없습니다. 하지만 계속 수신은 받을 수 있습니다. close() 함수는 채널로 루프를 돌리고자 할 때 활용될 수 있습니다.\n채널 range문 for range문으로 채널을 사용하면 for 루프는 채널이 닫힐 때까지 루프를 실행하다가 채널이 닫히면 루프를 종료합니다.\n1\tfor i := range ch { 2 fmt.Println(i) 3 } ","link":"https://thouy.github.io/posts/golang/goroutine_and_channel/","section":"posts","tags":null,"title":"[Golang] Goroutine \u0026 Channel"},{"body":"호이스팅이란 Hoist는 사전적으로 무거운 물건 및 무언가를 기계 등을 이용하여 위로 끌어 올리는 것(lift)을 의미합니다. 자바스크립트에서 호이스팅은 자바스크립트 Parser가 변수나 함수를 끌어 올려 최상단에 배치하는 것을 말합니다.\n실제로 코드가 상단으로 올라가는 것은 아닙니다. 자바스크립트 Parser가 내부적으로 최상단에 끌어 올려서 처리하게 되며, 이 때 메모리 상의 변화는 없습니다.\n호이스팅 대상 자바스크립트는 선언 구문만 호이스팅 합니다. 때문에 변수 선언 없이 먼저 변수를 사용하게 되더라도 예외가 발생하지 않습니다. 다만 그 변수는 사용되는 시점에 자동으로 기본 초기화 상태 (var 선언의 경우 undefined)가 됩니다.\n자동으로 undefined 초기화가 되는 경우는 var 선언에만 해당됩니다.\n아래의 코드를 실행하면 message에는 undefined가 출력됩니다.\n1console.log(message); // undefined 출력 2var message; // 이 구문은 파서에 의해 호이스팅 됩니다. 3message = \u0026#39;hoisting\u0026#39;; // 변수에 값 할당 하지만 선언 구문이 없으면 호이스팅이 발생하지 않기 때문에 변수를 읽을 때 예외가 발생합니다.\n1console.log(message); // ReferenceError 예외 발생 2message = \u0026#39;hoisting\u0026#39;; 호이스팅은 함수 선언에도 적용됩니다. 아래와 같이 함수를 먼저 호출하고 아래에 함수를 선언해도 파서에 의해 함수 선언은 상단으로 호이스팅 되기 때문에, 정상적으로 함수가 호출됩니다.\n1showMessage(\u0026#39;hoisting\u0026#39;); 2 3function showMessage(message) { 4 console.log(\u0026#34;Message : \u0026#34; + message); 5} 호이스팅 시 예외 상황 let과 const let과 const로 선언한 변수도 호이스팅 대상이지만, var와 달리 호이스팅 시 undefined로 변수가 초기화 되지는 않습니다. 때문에 변수 초기화 전에 변수를 읽으려고 하게 되면 예외가 발생됩니다.\n함수 표현식 변수에 함수를 할당하는 형태인 함수 표현식은 호이스팅 되지 않습니다.\n1showMessage(\u0026#39;hoisting\u0026#39;); // Uncaught TypeError: showMessage is not a function 발생 2var showMessage = function(message) { 3 console.log(\u0026#34;Message : \u0026#34; + message); 4} 아래는 Arrow function으로 함수 표현식을 작성한 코드입니다.\n1showMessage(\u0026#39;hoisting\u0026#39;); // Uncaught TypeError: showMessage is not a function 발생 2var showMessage = message =\u0026gt; console.log(\u0026#34;Message : \u0026#34; + message); ","link":"https://thouy.github.io/posts/javascript/hoisting/","section":"posts","tags":null,"title":"[Javascript] Hoisting (호이스팅)"},{"body":"","link":"https://thouy.github.io/posts/javascript/","section":"posts","tags":["index"],"title":"Javascript"},{"body":"Hello world ","link":"https://thouy.github.io/posts/test1/","section":"posts","tags":null,"title":"Test1"},{"body":"","link":"https://thouy.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://thouy.github.io/tags/index/","section":"tags","tags":null,"title":"index"},{"body":"","link":"https://thouy.github.io/series/","section":"series","tags":null,"title":"Series"},{"body":"","link":"https://thouy.github.io/tags/","section":"tags","tags":null,"title":"Tags"}]